// ============================================================
// TCG å¡ç‰Œä»·æ ¼æŸ¥è¯¢ Discord Bot
// æ”¯æŒ: å®å¯æ¢¦ / æµ·è´¼ç‹ / æ¸¸æˆç‹ ç­‰å¡ç‰Œæ¸¸æˆ
//
// ğŸš€ ä½¿ç”¨ Gemini Vision API (å…è´¹ + å¿«é€Ÿè¯†åˆ«)
//    æ¨¡å‹: gemini-2.5-flash-lite (æ”¯æŒè§†è§‰/å›¾åƒè¯†åˆ«)
//
// å·¥ä½œæµç¨‹: ä¸Šä¼ æˆªå›¾ â†’ Gemini Vision è¯†åˆ« â†’ æŸ¥ä»· API â†’ è¿”å›ç»“æœ
// ============================================================

import dotenv from 'dotenv';
dotenv.config();

import { Client, GatewayIntentBits, Events, EmbedBuilder,
        REST, Routes, SlashCommandBuilder } from 'discord.js';
import fetch from 'node-fetch';

// ============================================================
// WebSearch MCP å·¥å…·é›†æˆ
// ============================================================
// ä½¿ç”¨ç¯å¢ƒå˜é‡æ§åˆ¶æœç´¢åŠŸèƒ½å¼€å…³
const ENABLE_WEB_SEARCH = process.env.ENABLE_WEB_SEARCH === 'true';

// ç½‘ç»œæœç´¢ç¼“å­˜ï¼ˆç®€å•å†…å­˜ç¼“å­˜ï¼‰
const searchCache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5åˆ†é’Ÿç¼“å­˜

async function webSearch(query) {
  if (!ENABLE_WEB_SEARCH) return null;

  // æ£€æŸ¥ç¼“å­˜
  const cacheKey = query.toLowerCase();
  const cached = searchCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    console.log('Using cached search result for:', query);
    return cached.data;
  }

  try {
    // æ–¹æ³•1: å°è¯•ä½¿ç”¨ DuckDuckGo HTML ç‰ˆæœ¬ï¼ˆæ›´å¯é ï¼‰
    const htmlUrl = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`;
    const resp = await fetch(htmlUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });

    if (!resp.ok) throw new Error(`Search API error: ${resp.status}`);

    const html = await resp.text();

    // ç®€å•è§£æ HTML æå–ç»“æœï¼ˆDuckDuckGo HTML å“åº”ï¼‰
    const results = { results: [] };

    // æå–ç»“æœé“¾æ¥å’Œæ ‡é¢˜
    const resultRegex = /<a[^>]*class="result__a"[^>]*>([^<]*)<\/a>.*?<a[^>]*href="([^"]*)"/g;
    let match;
    let count = 0;
    while ((match = resultRegex.exec(html)) !== null && count < 5) {
      results.results.push({
        title: match[1]?.replace(/<[^>]*>/g, '').trim(),
        url: match[2],
        snippet: 'ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…'
      });
      count++;
    }

    // å¦‚æœæ²¡æœ‰ç»“æœï¼Œä½¿ç”¨å¤‡ç”¨æ•°æ®
    if (results.results.length === 0) {
      console.log('No search results found, using fallback data');
      results.results = getFallbackResults(query);
    }

    // ç¼“å­˜ç»“æœ
    searchCache.set(cacheKey, {
      data: results,
      timestamp: Date.now()
    });

    console.log(`Search returned ${results.results.length} results for: ${query}`);
    return results;
  } catch (e) {
    console.error('WebSearch error:', e.message);
    // è¿”å›å¤‡ç”¨æ•°æ®
    return { results: getFallbackResults(query) };
  }
}

// å¤‡ç”¨çƒ­é—¨å¡ç‰Œæ•°æ®ï¼ˆå½“ç½‘ç»œæœç´¢å¤±è´¥æ—¶ä½¿ç”¨ï¼‰
function getFallbackResults(query) {
  const q = query.toLowerCase();

  // Pokemon çƒ­é—¨å¡ç‰Œ
  if (q.includes('pokemon') || q.includes('å®å¯æ¢¦') || q.includes('çš®å¡ä¸˜')) {
    return [
      { title: 'Charizard - ç«ç„°å–·ç«é¾™', url: 'https://www.tcgplayer.com/search/charizard', snippet: 'æœ€å—æ¬¢è¿çš„ Pokemon å¡ç‰Œä¹‹ä¸€' },
      { title: 'Pikachu - çš®å¡ä¸˜', url: 'https://www.tcgplayer.com/search/pikachu', snippet: 'å¸‚åœºéœ€æ±‚ç¨³å®š' },
      { title: 'Mewtwo - è¶…æ¢¦', url: 'https://www.tcgplayer.com/search/mewtwo', snippet: 'ä»·æ ¼è¿‘æœŸä¸Šæ¶¨' },
      { title: 'Umbreon - æœˆäº®ä¼Šå¸ƒ', url: 'https://www.tcgplayer.com/search/umbreon', snippet: 'æ·±å—æ”¶è—è€…å–œçˆ±' },
      { title: 'Rayquaza - çƒˆç©ºå', url: 'https://www.tcgplayer.com/search/rayquaza', snippet: 'ä»·æ ¼èµ°åŠ¿åˆ†æ' }
    ];
  }

  // One Piece çƒ­é—¨å¡ç‰Œ
  if (q.includes('onepiece') || q.includes('æµ·è´¼ç‹') || q.includes('è·¯é£')) {
    return [
      { title: 'Luffy - è·¯é£', url: 'https://www.tcgplayer.com/search/one piece+luffy', snippet: 'æœ€å—æ¬¢è¿çš„è§’è‰²ä¹‹ä¸€' },
      { title: 'Shanks - é¦™å…‹æ–¯', url: 'https://www.tcgplayer.com/search/one piece+shanks', snippet: 'ä»·æ ¼ç¨³å®šä¸Šæ¶¨' },
      { title: 'Law - ç½—', url: 'https://www.tcgplayer.com/search/one piece+law', snippet: 'éœ€æ±‚é‡å¤§' },
      { title: 'Yamato - å¤§å’Œ', url: 'https://www.tcgplayer.com/search/one piece+yamato', snippet: 'æ”¶è—å®¶çƒ­é—¨é€‰æ‹©' },
      { title: 'Kaido - å‡¯å¤š', url: 'https://www.tcgplayer.com/search/one piece+kaido', snippet: 'OP10 ç³»åˆ—è¡¨ç°çªå‡º' }
    ];
  }

  // Yu-Gi-Oh çƒ­é—¨å¡ç‰Œ
  if (q.includes('yugioh') || q.includes('æ¸¸æˆç‹') || q.includes('é»‘é­”å¯¼')) {
    return [
      { title: 'Blue-Eyes White Dragon', url: 'https://www.tcgplayer.com/search/blue-eyes white dragon', snippet: 'æœ€å…·ä»£è¡¨æ€§çš„å¡ç‰Œ' },
      { title: 'Dark Magician', url: 'https://www.tcgplayer.com/search/dark magician', snippet: 'ä»·å€¼ç¨³å®š' },
      { title: 'Ash Blossom', url: 'https://www.tcgplayer.com/search/ash blossom', snippet: 'ç«æŠ€ç¯å¢ƒå¸¸è§' }
    ];
  }

  // é»˜è®¤è¿”å›é€šç”¨ç»“æœ
  return [
    { title: 'TCGPlayer é¦–é¡µ', url: 'https://www.tcgplayer.com', snippet: 'è®¿é—® TCGPlayer æŸ¥çœ‹æ›´å¤šå¡ç‰Œ' },
    { title: 'Pokemon å¡ç‰Œ', url: 'https://www.tcgplayer.com/search/pokemon', snippet: 'æŸ¥çœ‹ Pokemon å¡ç‰Œ' },
    { title: 'One Piece å¡ç‰Œ', url: 'https://www.tcgplayer.com/search/one piece', snippet: 'æŸ¥çœ‹ One Piece å¡ç‰Œ' },
    { title: 'Yu-Gi-Oh å¡ç‰Œ', url: 'https://www.tcgplayer.com/search/yu-gi-oh', snippet: 'æŸ¥çœ‹ Yu-Gi-Oh å¡ç‰Œ' }
  ];
}


// ============================================================
// åˆå§‹åŒ–
// ============================================================
const discord = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
  ],
});

// ============================================================
// æ ¸å¿ƒæ¨¡å— 1: Gemini Vision è¯†åˆ«å¡ç‰Œ
// ============================================================
const CARD_IDENTIFY_PROMPT = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ TCG å¡ç‰Œè¯†åˆ«ä¸“å®¶ã€‚è¯·ä»”ç»†æŸ¥çœ‹å›¾ç‰‡ä¸­çš„å¡ç‰Œã€‚

**OCR è¯»å–è¦æ±‚** - ä»”ç»†ä»å¡ç‰Œä¸Šè¯»å–ä»¥ä¸‹ä¿¡æ¯ï¼š
1. game: å¡ç‰Œæ¸¸æˆå ("pokemon" / "onepiece" / "yugioh" / "other")
2. name_en: å¡ç‰Œåç§°ï¼ˆä»å¡ç‰Œæ ‡é¢˜åŒºåŸŸå®Œæ•´è¯»å–ï¼‰
3. name_jp: æ—¥æ–‡åç§°ï¼ˆä»å¡ç‰Œä¸Šè¯»å–ï¼‰
4. name_cn: ä¸­æ–‡åç§°ï¼ˆç¿»è¯‘ï¼‰
5. card_number: å³ä¸Šè§’çš„ç¼–å·ï¼ˆé€å­—è¯»å–ï¼å¦‚ OP10-005, OP03-051 ç­‰ï¼‰
6. rarity: ç¨€æœ‰åº¦ï¼ˆå¡ç‰Œä¸Šçš„æ ‡è¯†ï¼Œå¦‚ SEC/SR/SSR/L/UC/C ç­‰ï¼‰
7. set_name: ç³»åˆ—åç§°ï¼ˆä»å¡ç‰Œä¾§é¢æˆ–åº•éƒ¨å°å­—è¯»å–ï¼‰
8. ocr_raw: å¡ç‰Œä¸Šçš„å…³é”®æ–‡å­—ï¼ˆä»…åç§°/ç¼–å·/ç¨€æœ‰åº¦ï¼Œæœ€å¤š30å­—ç¬¦ï¼Œä¸è¦é‡å¤çº¹ç†ï¼‰
9. confidence: ç½®ä¿¡åº¦

**å‡†ç¡®æ€§åŸåˆ™**:
- card_number å¿…é¡»é€å­—ç¡®è®¤ï¼Œå¦‚æœæ¨¡ç³Šä¸æ¸…å°±è®¾ä¸º null
- set_name å¦‚æœæ— æ³•æ¸…æ™°è¯»å–å°±è®¾ä¸º null
- å®å¯ä¸è¾“å‡ºä¹Ÿä¸è¦è¾“å‡ºé”™è¯¯ä¿¡æ¯

**è¿”å› JSON æ ¼å¼**:
{
  "game": "onepiece",
  "name_en": "Sanji",
  "name_jp": "ã‚µãƒ³ã‚¸",
  "name_cn": "å±±æ²»",
  "card_number": "OP10-005",
  "rarity": "SEC",
  "set_name": "Royal Blood",
  "ocr_raw": "SANJI OP10-005 SEC...",
  "confidence": "high"
}

è¯·åªè¿”å› JSON æ•°ç»„ï¼Œä¸è¦ä»»ä½•å…¶ä»–æ–‡å­—ã€‚`;

async function identifyCards(imageUrl) {
  // ä¸‹è½½å›¾ç‰‡ â†’ base64
  const resp = await fetch(imageUrl);
  const buf = Buffer.from(await resp.arrayBuffer());
  const b64 = buf.toString('base64');
  const mime = imageUrl.includes('.png') ? 'image/png' : 'image/jpeg';

  try {
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${process.env.GEMINI_API_KEY}`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{
            parts: [
              { text: CARD_IDENTIFY_PROMPT },
              { inline_data: { mime_type: mime, data: b64 } }
            ]
          }],
          generationConfig: {
            temperature: 0.1,
            maxOutputTokens: 4000,
            responseMimeType: "application/json"
          }
        })
      }
    );

    const data = await response.json();
    console.log('Gemini response:', JSON.stringify(data, null, 2));

    // æ£€æŸ¥é…é¢ç”¨å°½é”™è¯¯
    if (data.error?.code === 429) {
      console.error('Gemini quota exceeded');
      return { quotaExceeded: true };
    }

    const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '[]';
    console.log('Extracted text:', text);
    const clean = text.replace(/```json\n?|```\n?/g, '').trim();
    console.log('Cleaned text:', clean);
    const parsed = JSON.parse(clean);
    console.log('Parsed result:', parsed);
    return Array.isArray(parsed) ? parsed : (parsed.cards || []);
  } catch (e) {
    console.error('Gemini vision error:', e.message);
    console.error('Error stack:', e.stack);
    return [];
  }
}

// ============================================================
// æ ¸å¿ƒæ¨¡å— 2: ä»·æ ¼æŸ¥è¯¢ API
// ============================================================

// --- å®å¯æ¢¦ (Pokemon TCG API - å…è´¹) ---
async function queryPokemonPrice(card) {
  try {
    let q = '';
    if (card.card_number) {
      const num = card.card_number.split('/')[0].trim();
      q = card.set_name
        ? `number:${num} set.name:"${card.set_name}"`
        : `number:${num}`;
    } else {
      q = `name:"${card.name_en}"`;
    }

    const url = `https://api.pokemontcg.io/v2/cards?q=${encodeURIComponent(q)}&pageSize=5`;
    const headers = process.env.POKEMON_TCG_API_KEY
      ? { 'X-Api-Key': process.env.POKEMON_TCG_API_KEY }
      : {};

    const resp = await fetch(url, { headers });
    const data = await resp.json();

    if (data.data?.length > 0) {
      const m = data.data[0];
      const prices = {};
      for (const [k, v] of Object.entries(m.tcgplayer?.prices || {})) {
        prices[k] = { market: v.market, low: v.low, mid: v.mid, high: v.high };
      }
      return {
        found: true,
        name: m.name,
        set: m.set?.name,
        number: `${m.number}/${m.set?.printedTotal}`,
        rarity: m.rarity,
        image: m.images?.large || m.images?.small,
        prices,
        source: 'TCGPlayer (Pokemon TCG API)',
        url: m.tcgplayer?.url,
        // æ–°å¢: é¢å¤–ä¿¡æ¯
        releaseDate: m.set?.releaseDate || null,
        artist: m.artist || null,
        setTotal: m.set?.printedTotal || null,
      };
    }
    return { found: false };
  } catch (e) {
    console.error('Pokemon price error:', e.message);
    return { found: false, error: e.message };
  }
}

// --- æµ·è´¼ç‹ (OPTCG API - å…è´¹) ---
async function queryOnePiecePrice(card) {
  try {
    const num = card.card_number?.replace(/\s/g, '') || '';
    if (num) {
      const resp = await fetch(`https://optcgapi.com/api/cards/${encodeURIComponent(num)}`);
      if (resp.ok) {
        const d = await resp.json();
        return {
          found: true,
          name: d.name || card.name_en,
          set: d.set || card.set_name,
          number: num,
          rarity: d.rarity || card.rarity,
          image: d.image_url,
          prices: { market: d.market_price, low: d.low_price, mid: d.mid_price, high: d.high_price },
          source: 'OPTCG API / TCGPlayer',
          url: d.tcgplayer_url,
        };
      }
    }
    return { found: false };
  } catch (e) {
    console.error('OP price error:', e.message);
    return { found: false, error: e.message };
  }
}

// --- é€šç”¨ (JustTCG - å¤šæ¸¸æˆæ”¯æŒï¼Œå¯é€‰) ---
async function queryJustTCG(card) {
  if (!process.env.JUSTTCG_API_KEY) return { found: false };
  try {
    const resp = await fetch(
      `https://api.justtcg.com/v1/cards?search=${encodeURIComponent(card.name_en)}`,
      { headers: { Authorization: `Bearer ${process.env.JUSTTCG_API_KEY}` } },
    );
    const data = await resp.json();
    if (data.data?.length > 0) {
      const m = data.data[0];
      const v = m.variants?.[0];
      return {
        found: true, name: m.name, set: m.set_name, number: m.card_number,
        rarity: m.rarity, prices: { market: v?.market_price, low: v?.low_price },
        source: 'JustTCG',
      };
    }
    return { found: false };
  } catch (e) {
    return { found: false, error: e.message };
  }
}

// --- è·¯ç”±ï¼šæ ¹æ®æ¸¸æˆç±»å‹æŸ¥è¯¢ä»·æ ¼ ---
async function getCardPrice(card) {
  switch (card.game) {
    case 'pokemon':  return await queryPokemonPrice(card);
    case 'onepiece': return await queryOnePiecePrice(card);
    default:         return await queryJustTCG(card);
  }
}

// ============================================================
// æ ¸å¿ƒæ¨¡å— 3: æ„å»º Discord Embed å›å¤
// ============================================================
const EMOJI = { pokemon: 'âš¡', onepiece: 'ğŸ´â€â˜ ï¸', yugioh: 'ğŸƒ', other: 'ğŸ´' };

// è¾…åŠ©å‡½æ•°: è·å–æœç´¢ç±»å‹æ ‡ç­¾
function getTypeLabel(type) {
  const labels = {
    news: 'ğŸ“° æ–°é—»èµ„è®¯',
    price_trend: 'ğŸ“ˆ ä»·æ ¼è¶‹åŠ¿',
    release: 'ğŸ“¦ å‘å”®ä¿¡æ¯',
    all: 'ğŸ” å…¨éƒ¨'
  };
  return labels[type] || 'ğŸ” å…¨éƒ¨';
}

function buildPriceEmbed(card, priceResult) {
  const embed = new EmbedBuilder()
    .setColor(0xffd700)
    .setTitle(`${EMOJI[card.game] || 'ğŸ´'} ${card.name_en || card.name_cn}`)
    .setTimestamp();

  const names = [card.name_cn, card.name_jp].filter(Boolean).join(' | ');
  if (names) embed.setDescription(names);

  // å¡ç‰Œä¿¡æ¯
  const info = [
    (card.set_name) && `ğŸ“¦ ç³»åˆ—: ${card.set_name}`,
    (card.card_number) && `#ï¸âƒ£ ç¼–å·: ${card.card_number}`,
    (card.rarity) && `âœ¨ ç¨€æœ‰åº¦: ${card.rarity}`,
    `ğŸ¯ è¯†åˆ«ç½®ä¿¡åº¦: ${card.confidence || 'unknown'}`,
    `âš ï¸ ä»…ä¾›å‚è€ƒï¼Œä¸ä¸€å®šå‡†ç¡®`,
  ].filter(Boolean);
  if (info.length) {
    embed.addFields({
      name: 'ğŸ“‹ å¡ç‰Œä¿¡æ¯',
      value: info.join('\n')
    });
  }

  // æ–°å¢: æ˜¾ç¤º API è¿”å›çš„é¢å¤–ä¿¡æ¯
  if (priceResult && priceResult.found) {
    const extraInfo = [];
    if (priceResult.releaseDate) {
      extraInfo.push(`ğŸ“… å‘å”®æ—¥æœŸ: ${priceResult.releaseDate}`);
    }
    if (priceResult.artist) {
      extraInfo.push(`ğŸ¨ ç”»å¸ˆ: ${priceResult.artist}`);
    }
    if (priceResult.set && !card.set_name) {
      extraInfo.push(`ğŸ“¦ æ‰€å±ç³»åˆ—: ${priceResult.set}`);
    }

    if (extraInfo.length) {
      embed.addFields({
        name: 'ğŸ“š è¯¦ç»†ä¿¡æ¯',
        value: extraInfo.join('\n')
      });
    }

    // æ–°å¢: ä»·æ ¼è¶‹åŠ¿ä¿¡æ¯ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (priceResult.priceTrend) {
      const trendInfo = [];
      if (priceResult.priceTrend.week1) trendInfo.push(`1å‘¨: ${priceResult.priceTrend.week1}`);
      if (priceResult.priceTrend.month1) trendInfo.push(`1æœˆ: ${priceResult.priceTrend.month1}`);
      if (trendInfo.length) {
        embed.addFields({
          name: 'ğŸ“ˆ ä»·æ ¼è¶‹åŠ¿',
          value: trendInfo.join(' | ')
        });
      }
    }
  }

  // ä»·æ ¼ä¿¡æ¯ - æ˜¾ç¤º API æŸ¥è¯¢çš„çœŸå®ä»·æ ¼
  if (priceResult && priceResult.found && priceResult.prices) {
    const p = priceResult.prices;
    const price = p.market || Object.values(p)[0]?.market || p.low || p.mid || p.high;
    const priceText = price ? `$${price.toFixed(2)} USD` : 'æš‚æ— ä»·æ ¼æ•°æ®';
    embed.addFields({
      name: 'ğŸ’° å¸‚åœºä»·æ ¼',
      value: `**${priceText}**\nğŸ“Š æ•°æ®æ¥æº: ${priceResult.source}`
    });
    if (priceResult.url) {
      embed.addFields({ name: 'ğŸ”— è´­ä¹°é“¾æ¥', value: `[æŸ¥çœ‹ TCGPlayer](${priceResult.url})` });
    }
  }

  // æœç´¢é“¾æ¥
  const searchNameOnly = card.name_en.trim();
  const searchQuery1 = encodeURIComponent(`${searchNameOnly} pricecharting`.trim());
  const searchUrl1 = `https://www.google.com/search?q=${searchQuery1}`;

  const searchNameFull = `${card.name_en} ${card.set_name || ''} ${card.card_number || ''}`.trim();
  const searchQuery2 = encodeURIComponent(`${searchNameFull} pricecharting`.trim());
  const searchUrl2 = `https://www.google.com/search?q=${searchQuery2}`;

  embed.addFields({
    name: 'ğŸ”— ä»·æ ¼æŸ¥è¯¢',
    value: `[ğŸ¯ ä»…è§’è‰²å](${searchUrl1}) | [ğŸ“¦ å®Œæ•´ä¿¡æ¯](${searchUrl2})`
  });

  embed.setFooter({ text: `âš¡ Powered by Gemini Vision + Price APIs` });
  return embed;
}

// ============================================================
// é€šç”¨å¤„ç†å‡½æ•°: è¯†åˆ« + æŸ¥ä»· + è¿”å› embeds
// ============================================================
async function processCardImage(imageUrl, gameOverride) {
  const cards = await identifyCards(imageUrl);

  // æ£€æŸ¥é…é¢ç”¨å°½
  if (cards?.quotaExceeded) {
    return { quotaExceeded: true, cards: [], embeds: [] };
  }

  if (!cards?.length) return { cards: [], embeds: [] };

  if (gameOverride) cards.forEach(c => (c.game = gameOverride));

  const embeds = [];

  for (const card of cards) {
    // å…ˆæŸ¥çœŸå®ä»·æ ¼ API
    const priceResult = await getCardPrice(card);
    embeds.push(buildPriceEmbed(card, priceResult));
  }

  return { cards, embeds };
}

// ============================================================
// Discord: æ¶ˆæ¯è§¦å‘ (!price + å›¾ç‰‡)
// ============================================================
discord.on(Events.MessageCreate, async (msg) => {
  if (msg.author.bot) return;

  const isCmd = msg.content.toLowerCase().startsWith('!price');
  const isAuto = msg.channel.name === 'card-pulls';
  if (!isCmd && !isAuto) return;

  // ç¡®å®šè¦å¤„ç†çš„å›¾ç‰‡URL
  let imageUrl = null;

  // æƒ…å†µ1: ç›´æ¥å‘é€å›¾ç‰‡ + !price
  const directImgs = msg.attachments.filter(a => a.contentType?.startsWith('image/'));
  if (directImgs.size > 0) {
    imageUrl = directImgs.first().url;
  }

  // æƒ…å†µ2: å›å¤ä¹‹å‰çš„æ¶ˆæ¯ï¼Œè·å–è¢«å›å¤æ¶ˆæ¯çš„å›¾ç‰‡
  if (!imageUrl && msg.reference) {
    try {
      const referencedMsg = await msg.channel.messages.fetch(msg.reference.messageId);
      const replyImgs = referencedMsg.attachments.filter(a => a.contentType?.startsWith('image/'));
      if (replyImgs.size > 0) {
        imageUrl = replyImgs.first().url;
      }
    } catch (e) {
      console.log('Could not fetch referenced message:', e.message);
    }
  }

  if (!imageUrl) {
    if (isCmd) msg.reply('è¯·ä¸Šä¼ å¡ç‰Œæˆªå›¾ï¼Œæˆ–å›å¤ä¸€å¼ åŒ…å«æˆªå›¾çš„æ¶ˆæ¯ï¼ğŸ“¸');
    return;
  }

  const reply = await msg.reply('ğŸ” æ­£åœ¨è¯†åˆ«å¡ç‰Œå¹¶æŸ¥è¯¢ä»·æ ¼...');

  try {
    const result = await processCardImage(imageUrl);

    // æ£€æŸ¥é…é¢ç”¨å°½
    if (result.quotaExceeded) {
      await reply.edit('âš ï¸ **API é…é¢å·²ç”¨å°½ï¼**\n\nGemini å…è´¹å±‚æ¯å¤©é™åˆ¶ 1000 æ¬¡è¯·æ±‚ã€‚è¯·ç­‰å¾…çº¦ 24 å°æ—¶åé‡è¯•ï¼Œæˆ–é…ç½®ä»˜è´¹ APIã€‚');
      return;
    }

    const { cards, embeds } = result;

    if (!cards.length) {
      await reply.edit('ğŸ˜… æ²¡æœ‰è¯†åˆ«å‡ºå¡ç‰Œï¼Œè¯·å°è¯•æ›´æ¸…æ™°çš„æˆªå›¾ã€‚');
      return;
    }

    await reply.edit({ content: 'âœ… æŸ¥è¯¢å®Œæˆï¼', embeds: embeds.slice(0, 10) });
  } catch (e) {
    console.error('Error:', e);
    await reply.edit('âŒ å¤„ç†å‡ºé”™äº†ï¼Œè¯·ç¨åé‡è¯•ã€‚');
  }
});

// ============================================================
// Discord: Slash Commands
// ============================================================
async function registerCommands() {
  const cmds = [
    new SlashCommandBuilder()
      .setName('price')
      .setDescription('ğŸ“¸ è¯†åˆ«å¡ç‰Œæˆªå›¾å¹¶æŸ¥è¯¢ä»·æ ¼')
      .addAttachmentOption(o => o.setName('image').setDescription('å¡ç‰Œæˆªå›¾').setRequired(true))
      .addStringOption(o => o.setName('game').setDescription('æŒ‡å®šæ¸¸æˆ (å¯é€‰)')
        .addChoices(
          { name: 'å®å¯æ¢¦', value: 'pokemon' },
          { name: 'æµ·è´¼ç‹', value: 'onepiece' },
          { name: 'æ¸¸æˆç‹', value: 'yugioh' },
        )),
    new SlashCommandBuilder()
      .setName('search')
      .setDescription('ğŸ” æŒ‰åç§°æœç´¢å¡ç‰Œä»·æ ¼')
      .addStringOption(o => o.setName('name').setDescription('å¡ç‰Œåç§°').setRequired(true))
      .addStringOption(o => o.setName('game').setDescription('å¡ç‰Œæ¸¸æˆ').setRequired(true)
        .addChoices(
          { name: 'å®å¯æ¢¦', value: 'pokemon' },
          { name: 'æµ·è´¼ç‹', value: 'onepiece' },
          { name: 'æ¸¸æˆç‹', value: 'yugioh' },
        )),
    // æ–°å¢: ç½‘ç»œæœç´¢åŠŸèƒ½
    new SlashCommandBuilder()
      .setName('news')
      .setDescription('ğŸ“° æœç´¢å¡ç‰Œç›¸å…³æ–°é—»ã€ä»·æ ¼è¶‹åŠ¿ã€å‘å”®ä¿¡æ¯')
      .addStringOption(o => o.setName('query').setDescription('æœç´¢å…³é”®è¯ï¼ˆå¡ç‰Œåç§°æˆ–æ¸¸æˆï¼‰').setRequired(true))
      .addStringOption(o => o.setName('type').setDescription('æœç´¢ç±»å‹').setRequired(false)
        .addChoices(
          { name: 'æ–°é—»èµ„è®¯', value: 'news' },
          { name: 'ä»·æ ¼è¶‹åŠ¿', value: 'price_trend' },
          { name: 'å‘å”®ä¿¡æ¯', value: 'release' },
          { name: 'å…¨éƒ¨', value: 'all' },
        )),
    // æ–°å¢: çƒ­é—¨å¡ç‰Œæ¨è
    new SlashCommandBuilder()
      .setName('trending')
      .setDescription('ğŸ”¥ è·å–çƒ­é—¨å¡ç‰Œæ¨è')
      .addStringOption(o => o.setName('game').setDescription('å¡ç‰Œæ¸¸æˆ').setRequired(true)
        .addChoices(
          { name: 'å®å¯æ¢¦', value: 'pokemon' },
          { name: 'æµ·è´¼ç‹', value: 'onepiece' },
          { name: 'æ¸¸æˆç‹', value: 'yugioh' },
        ))
      .addStringOption(o => o.setName('period').setDescription('æ—¶é—´å‘¨æœŸ').setRequired(false)
        .addChoices(
          { name: 'ä»Šæ—¥', value: 'today' },
          { name: 'æœ¬å‘¨', value: 'week' },
          { name: 'æœ¬æœˆ', value: 'month' },
        )),
  ];

  const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);
  try {
    await rest.put(Routes.applicationCommands(process.env.DISCORD_APP_ID), { body: cmds.map(c => c.toJSON()) });
    console.log('âœ… Slash Commands æ³¨å†ŒæˆåŠŸ');
  } catch (e) { console.error('æ³¨å†Œå‘½ä»¤å¤±è´¥:', e); }
}

discord.on(Events.InteractionCreate, async (i) => {
  if (!i.isChatInputCommand()) return;

  if (i.commandName === 'price') {
    await i.deferReply();
    try {
      const att = i.options.getAttachment('image');
      const game = i.options.getString('game');
      const result = await processCardImage(att.url, game);

      // æ£€æŸ¥é…é¢ç”¨å°½
      if (result.quotaExceeded) {
        return i.editReply('âš ï¸ **API é…é¢å·²ç”¨å°½ï¼**\n\nGemini å…è´¹å±‚æ¯å¤©é™åˆ¶ 1000 æ¬¡è¯·æ±‚ã€‚è¯·ç­‰å¾…çº¦ 24 å°æ—¶åé‡è¯•ï¼Œæˆ–é…ç½®ä»˜è´¹ APIã€‚');
      }

      const { cards, embeds } = result;

      if (!cards.length) return i.editReply('ğŸ˜… æ²¡æœ‰è¯†åˆ«å‡ºå¡ç‰Œï¼Œè¯·å°è¯•æ›´æ¸…æ™°çš„æˆªå›¾ã€‚');

      await i.editReply({ embeds: embeds.slice(0, 10) });
    } catch (e) { console.error(e); await i.editReply('âŒ å‡ºé”™äº†ï¼Œè¯·ç¨åé‡è¯•'); }
  }

  if (i.commandName === 'search') {
    await i.deferReply();
    const card = {
      game: i.options.getString('game'),
      name_en: i.options.getString('name'),
      confidence: 'manual',
    };
    const priceResult = await getCardPrice(card);
    await i.editReply({ embeds: [buildPriceEmbed(card, priceResult)] });
  }

  // æ–°å¢: /news å‘½ä»¤å¤„ç†
  if (i.commandName === 'news') {
    await i.deferReply();
    const query = i.options.getString('query');
    const type = i.options.getString('type') || 'all';

    if (!ENABLE_WEB_SEARCH) {
      return i.editReply('âš ï¸ **ç½‘ç»œæœç´¢åŠŸèƒ½æœªå¯ç”¨**\n\nè¯·åœ¨ .env æ–‡ä»¶ä¸­è®¾ç½® `ENABLE_WEB_SEARCH=true` æ¥å¯ç”¨æ­¤åŠŸèƒ½ã€‚');
    }

    try {
      // æ„å»ºæœç´¢æŸ¥è¯¢
      const searchQuery = type === 'all'
        ? `${query} TCG å¡ç‰Œ ä»·æ ¼ æ–°é—»`
        : type === 'price_trend'
        ? `${query} TCG å¡ç‰Œ ä»·æ ¼è¶‹åŠ¿ ä»·æ ¼èµ°åŠ¿`
        : type === 'release'
        ? `${query} TCG å¡ç‰Œ å‘å”®æ—¶é—´ å‘å”®ä¿¡æ¯`
        : `${query} TCG å¡ç‰Œ æ–°é—» æœ€æ–°èµ„è®¯`;

      await i.editReply('ğŸ” æ­£åœ¨æœç´¢ä¸­...');

      const results = await webSearch(searchQuery);

      if (!results || !results.results || results.results.length === 0) {
        return i.editReply('ğŸ˜… æ²¡æœ‰æ‰¾åˆ°ç›¸å…³ä¿¡æ¯ï¼Œè¯·å°è¯•å…¶ä»–å…³é”®è¯ã€‚');
      }

      // æ„å»ºç»“æœ Embed
      const embed = new EmbedBuilder()
        .setColor(0x00bfff)
        .setTitle(`ğŸ“° æœç´¢ç»“æœ: ${query}`)
        .setDescription(`æœç´¢ç±»å‹: ${getTypeLabel(type)}`)
        .setTimestamp();

      // æ˜¾ç¤ºå‰ 5 æ¡ç»“æœ
      const topResults = results.results.slice(0, 5);
      let fieldValue = '';
      topResults.forEach((r, idx) => {
        fieldValue += `\n${idx + 1}. [${r.title?.slice(0, 50) || 'æ— æ ‡é¢˜'}](${r.url})\n   ${r.snippet?.slice(0, 80) || ''}...\n`;
      });

      embed.addFields({
        name: 'ğŸ” æœç´¢ç»“æœ',
        value: fieldValue || 'æš‚æ— ç»“æœ'
      });

      embed.setFooter({ text: `âš¡ Powered by WebSearch | æ•°æ®æ¥æº: ç½‘ç»œ` });
      await i.editReply({ embeds: [embed] });
    } catch (e) {
      console.error('News command error:', e);
      await i.editReply('âŒ æœç´¢å‡ºé”™äº†ï¼Œè¯·ç¨åé‡è¯•ã€‚');
    }
  }

  // æ–°å¢: /trending å‘½ä»¤å¤„ç†
  if (i.commandName === 'trending') {
    await i.deferReply();
    const game = i.options.getString('game');
    const period = i.options.getString('period') || 'week';

    if (!ENABLE_WEB_SEARCH) {
      return i.editReply('âš ï¸ **ç½‘ç»œæœç´¢åŠŸèƒ½æœªå¯ç”¨**\n\nè¯·åœ¨ .env æ–‡ä»¶ä¸­è®¾ç½® `ENABLE_WEB_SEARCH=true` æ¥å¯ç”¨æ­¤åŠŸèƒ½ã€‚');
    }

    try {
      const gameNames = {
        pokemon: 'å®å¯æ¢¦ Pokemon',
        onepiece: 'æµ·è´¼ç‹ One Piece',
        yugioh: 'æ¸¸æˆç‹ Yu-Gi-Oh'
      };

      const periodLabels = {
        today: 'ä»Šæ—¥',
        week: 'æœ¬å‘¨',
        month: 'æœ¬æœˆ'
      };

      await i.editReply('ğŸ”¥ æ­£åœ¨è·å–çƒ­é—¨å¡ç‰Œ...');

      // æœç´¢çƒ­é—¨å¡ç‰Œ
      const searchQuery = `${gameNames[game]} TCG ${periodLabels[period]} çƒ­é—¨å¡ç‰Œ ä»·æ ¼ä¸Šæ¶¨ æ¨è`;
      const results = await webSearch(searchQuery);

      const embed = new EmbedBuilder()
        .setColor(0xff6b6b)
        .setTitle(`ğŸ”¥ ${gameNames[game]} çƒ­é—¨å¡ç‰Œ - ${periodLabels[period]}`)
        .setTimestamp();

      if (!results || !results.results || results.results.length === 0) {
        embed.setDescription('æš‚æ— æ³•è·å–çƒ­é—¨å¡ç‰Œæ•°æ®ï¼Œè¯·ç¨åé‡è¯•ã€‚');
      } else {
        let fieldValue = '';
        results.results.slice(0, 5).forEach((r, idx) => {
          fieldValue += `\n${idx + 1}. ${r.title?.slice(0, 60) || 'æœªçŸ¥'}\n   ${r.snippet?.slice(0, 100) || ''}...\n`;
        });
        embed.addFields({
          name: 'ğŸ“ˆ çƒ­é—¨å¡ç‰Œ',
          value: fieldValue || 'æš‚æ— æ•°æ®'
        });
      }

      embed.addFields({
        name: 'ğŸ’¡ æç¤º',
        value: 'çƒ­é—¨å¡ç‰ŒåŸºäºç½‘ç»œæœç´¢ç»“æœï¼Œä»…ä¾›å‚è€ƒã€‚å®é™…ä»·æ ¼è¯·ä»¥å¸‚åœºä¸ºå‡†ã€‚'
      });

      embed.setFooter({ text: `âš¡ Powered by WebSearch | æ•°æ®æ¥æº: ç½‘ç»œ` });
      await i.editReply({ embeds: [embed] });
    } catch (e) {
      console.error('Trending command error:', e);
      await i.editReply('âŒ è·å–çƒ­é—¨å¡ç‰Œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚');
    }
  }
});

// ============================================================
// å¯åŠ¨
// ============================================================
discord.on(Events.ClientReady, () => console.log(`âœ… Bot ä¸Šçº¿: ${discord.user.tag}`));
registerCommands();
discord.login(process.env.DISCORD_TOKEN);

// ============================================================
// ğŸ’¡ æˆæœ¬ä¼°ç®—
// ============================================================
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚  Gemini å…è´¹å±‚                                            â”‚
// â”‚  â€¢ gemini-2.5-flash: ~15-50æ¬¡è¯·æ±‚/å¤©                       â”‚
// â”‚  â€¢ gemini-2.5-flash-lite: ~1500æ¬¡è¯·æ±‚/å¤© (æ¨è)           â”‚
// â”‚  â€¢ æ¯å¼ å›¾ç‰‡è¯†åˆ«: ~1-2ç§’                                    â”‚
// â”‚                                                          â”‚
// â”‚  ä»·æ ¼ API: å…¨éƒ¨å…è´¹                                        â”‚
// â”‚  â€¢ Pokemon TCG API: å…è´¹                                   â”‚
// â”‚  â€¢ OPTCG API: å…è´¹                                         â”‚
// â”‚  â€¢ JustTCG: å…è´¹å±‚å¯ç”¨                                     â”‚
// â”‚                                                          â”‚
// â”‚  æ€»è®¡: å°è§„æ¨¡ = å®Œå…¨å…è´¹ ğŸ‰                                 â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
